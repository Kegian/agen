package gen

import (
	"errors"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/Kegian/agen/openapi/gen"
	"github.com/Kegian/agen/openapi/parser"

	"github.com/spf13/cobra"
)

var (
	flagGenType = genTypeAll
	inputPath   string
	outputPath  string
	verbose     bool
)

func init() {
	GenCmd.Flags().VarP(&flagGenType, "type", "t", `Generation type, allowed: "all", "oapi", "ogen"`)
	GenCmd.Flags().StringVarP(&inputPath, "input", "i", "", `Path to input api file, example: "api.yml"`)
	_ = GenCmd.MarkFlagRequired("input")
	GenCmd.Flags().StringVarP(&outputPath, "output", "o", "", `Path to output folder, example: "internal/generated/"`)
	GenCmd.Flags().BoolVarP(&verbose, "verbose", "v", false, `Verbose print parsed schema`)
}

var GenCmd = &cobra.Command{
	Use:   "gen",
	Short: "Generate openapi and ogen files",
	RunE: func(_ *cobra.Command, _ []string) error {
		if flagGenType != genTypeOAPI && outputPath == "" {
			return errors.New("flag 'output' should be specified for generating ogen files")
		}

		if flagGenType != genTypeOAPI {
			_, err := exec.LookPath("ogen")
			if err != nil {
				return errors.New(`ogen not found, install it via "go install -v github.com/ogen-go/ogen/cmd/ogen@latest"`)
			}
		}

		data, err := os.ReadFile(inputPath)
		if err != nil {
			return err
		}

		document, err := parser.ParseDocument(data)
		if err != nil {
			fmt.Println(err)
			os.Exit(1)
		}
		if verbose {
			parser.PrettyPrint(document)
		}
		spec, err := gen.GenerateSpec(document)
		if err != nil {
			fmt.Println(err)
			os.Exit(1)
		}

		switch {
		case outputPath == "":
			fmt.Println(spec)
		case flagGenType == genTypeOAPI:
			err := os.WriteFile(outputPath, []byte(spec), 0644)
			if err != nil {
				return err
			}
		default:
			swaggerPath := filepath.Join(outputPath, "server")
			err := os.MkdirAll(swaggerPath, os.ModePerm)
			if err != nil {
				return err
			}
			specPath := filepath.Join(swaggerPath, "openapi.yml")
			err = os.WriteFile(specPath, []byte(spec), 0644)
			if err != nil {
				return err
			}
			swaggerGenPath := filepath.Join(swaggerPath, "swagger_gen.go")
			err = os.WriteFile(swaggerGenPath, []byte(swaggerGen), 0644)
			if err != nil {
				return err
			}
			serverGenPath := filepath.Join(swaggerPath, "server_gen.go")
			serverGenFinal := strings.ReplaceAll(serverGen, "${URL}", document.Settings.URL)
			err = os.WriteFile(serverGenPath, []byte(serverGenFinal), 0644)
			if err != nil {
				return err
			}

			ogenPath := filepath.Join(outputPath, "oapi")

			ogen := exec.Command(
				"ogen",
				"--target", ogenPath,
				"--package", "oapi",
				"--clean",
				specPath,
			)
			ogen.Stdout = os.Stdout
			ogen.Stderr = os.Stdout

			err = ogen.Run()
			if err != nil {
				return err
			}
		}

		return nil
	},
}

type genType string

const (
	genTypeAll  genType = "all"
	genTypeOAPI genType = "oapi"
	genTypeOGen genType = "ogen"
)

// String is used both by fmt.Print and by Cobra in help text
func (e *genType) String() string {
	return string(*e)
}

// Set must have pointer receiver so it doesn't change the value of a copy
func (e *genType) Set(v string) error {
	switch v {
	case "all", "oapi", "ogen":
		*e = genType(v)
		return nil
	default:
		return errors.New(`must be one of "all", "oapi", or "ogen"`)
	}
}

// Type is only used in help text
func (e *genType) Type() string {
	return "genType"
}

var swaggerGen = `// Code generated by agen, DO NOT EDIT.

package server

import (
	_ "embed"
	"net/http"

	"github.com/flowchartsman/swaggerui"
)

//go:embed openapi.yml
var SwaggerSpec []byte

func SwaggerHandler(prefix string) http.Handler {
	return http.StripPrefix(prefix, swaggerui.Handler(SwaggerSpec))
}
`

var serverGen = `// Code generated by agen, DO NOT EDIT.

package server

import (
	"fmt"
	"net/http"

	"github.com/Kegian/agen"
	"go.uber.org/zap"
)

type Server struct {
	Addr string
	Mux  *http.ServeMux
}

func New(addr string, srv http.Handler) *Server {
	mux := http.NewServeMux()
	mux.Handle("/api/v1/", http.StripPrefix("/api/v1", agen.SentryMiddleware(srv)))
	mux.Handle("/swagger/", SwaggerHandler("/swagger"))
	mux.Handle("/ready", http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {
		w.Write([]byte("OK"))
	}))
	return &Server{Addr: addr, Mux: mux}
}

func (s *Server) Run() error {
	zap.L().Info(fmt.Sprintf("start listenning on %s ...", s.Addr))
	return http.ListenAndServe(s.Addr, s.Mux)
}
`
